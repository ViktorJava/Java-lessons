package arrays.stack;

/**
 * При использовании стека, есть доступ только к последнему добавленному элементу.
 * Удалив этот элемент, пользователь получает доступ к предпоследнему элементу и тд.
 * Таким образом эта структура данных реализует принцип LIFO (Last In First Out).
 * Для удобства можно провести аналогию со стопкой тарелок или магазином пистолета
 * (последний заряженный патрон, будет подан в патронник первым).
 * Многие микропроцессоры имеют стековую архитектуру. Когда происходит вызов метода,
 * адрес возврата и аргументы заносятся в стек, а при выходе изымаются из него.
 *
 * @author ViktorJava (gipsyscrew@gmail.com)
 * @version 0.1
 * @since 05.11.2019
 */
class Stack {
    private int mSize; //mSize - максимальный размер
    private int[] stackArray;
    private int top; //голова стека

    /**
     * Конструктор
     *
     * @param m максимальный размер стека
     */
    public Stack(int m) {
        this.mSize = m;
        stackArray = new int[mSize];
        top = -1;
    }

    /**
     * Увеличиваем индекс массива и добавляем на указанную позицию переданный элемент.
     *
     * @param element добавить элемент в стек
     */
    public void addElement(int element) {
        stackArray[++top] = element;
    }

    /**
     * Для удаления существующего top элемента достаточно уменьшить индекс массива.
     * Таким образом вершиной стека станет предпоследней элемент,
     * а последний элемент будет удален с помощью Garbage Collector
     *
     * @return обновленный стек
     */
    public int deleteElement() {
        return stackArray[top--];
    }

    /**
     * Метод возвращает пользователю элемент, который находится на вершине стека.
     *
     * @return вершина стека
     */
    public int readTop() {
        return stackArray[top];
    }

    /**
     * Возвращает true (если массив данных пустой, индекс элемента top = 1,
     * именно для этого задавали в конструкторе такое начальное значение для данной переменной).
     *
     * @return true если стек пустой
     */
    public boolean isEmpty() {
        return (top == -1);
    }

    /**
     * Метод возвращает значение true (в той ситуации, когда массив данных полностью заполнен
     * и нет возможности добавить еще один элемент).
     *
     * @return true если стек заполнен
     */
    public boolean isFull() {
        return (top == mSize - 1);
    }

}
